<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web-Based Intruder Detection</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
        }
        h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-align: center;
            color: #2c3e50;
        }
       #video-container {
            position: relative;
            border: 2px solid #3498db;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
           margin-bottom:20px;
           overflow:hidden; /* prevent out of bound canvas issues */
           display:flex;
           align-items:center;
           justify-content:center;
        }
        #canvas {
           position: absolute;
            top:0;
            left:0;
             pointer-events:none; /*  pass through events to video below */
        }
        #video {
           display: block;
            width: 100%;
            height: auto;
            max-width: 640px;
             max-height: 480px;
        }

        #controls {
            margin-top: 20px;
            text-align: center;
             display: flex;
             flex-direction: column;
            align-items:center;
            justify-content:center;
        }

        .control-button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            background-color: #3498db;
            color: #fff;
            border: none;
            border-radius: 5px;
             font-size:1em;
            transition: background-color 0.3s ease;
        }
         .control-button:hover {
            background-color: #2980b9;
        }

        input[type="file"] {
             color:#fff;
              background-color: #3498db;
           font-size:1em;
        }
        input[type="file"]::file-selector-button {
             color: #fff;
           background-color: #2980b9;
           border:none;
           padding:10px 20px;
           border-radius:5px;
           transition: background-color 0.3s ease;
       }
      input[type="file"]::file-selector-button:hover {
         background-color: #1f6791;
      }
        #message {
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
        }
        #captureButton {
             display: block;
             margin: 20px auto;
            padding: 10px 20px;
             cursor: pointer;
            background-color: #e74c3c;
            color: #fff;
            border: none;
            border-radius: 5px;
           font-size:1em;
           transition: background-color 0.3s ease;
        }
        #captureButton:hover {
           background-color: #c0392b;
        }
        #recordingIndicator {
            margin-top: 5px;
            color: red;
            font-weight: bold;
            display: none;
        }

        @media (max-width: 768px) {
              #video {
                 width: 100%;
                 height: auto;
               }
           .control-button, input[type="file"] {
             padding: 8px 16px;
           font-size:0.9em;
           }
           h1 {
              font-size:2em;
           }
        }
    </style>
     <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
     <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/face-detection"></script>
</head>
<body>
    <h1>Real-time Intruder Detection System</h1>
   <div id="video-container">
      <video id="video" autoplay muted></video>
      <canvas id="canvas" width="640" height="480"></canvas>
    </div>

    <div id="controls">
        <button id="webcamButton" class="control-button">Start Webcam</button>
         <span> 또는 </span>
        <input type="file" id="fileInput" accept="video/*">
       <button id="captureButton" class="control-button">Start Recording</button>
        <div id="recordingIndicator">Recording...</div>
    </div>
    <div id="message"></div>

   <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const webcamButton = document.getElementById('webcamButton');
        const fileInput = document.getElementById('fileInput');
        const captureButton = document.getElementById('captureButton');
        const messageDiv = document.getElementById('message');
        const recordingIndicator = document.getElementById('recordingIndicator');

        let poseModel;
        let faceModel;
        let prevKeypoints = null;
        let prevAngles = {};
        const movementThreshold = 20;
        const angleChangeThreshold = 15;
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let recognizedFaces = [];
        let captureCount = 0;

        async function loadModels() {
            try {
                poseModel = await poseDetection.createDetector(poseDetection.SupportedModels.MoveNet, {
                    modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
                });
                faceModel = await faceDetection.createDetector(faceDetection.SupportedModels.MediaPipeFaceDetector);
            } catch (error) {
                console.error("Error loading models:", error);
                messageDiv.textContent = "Error loading detection models.";
                messageDiv.style.color = "red";
            }
        }

        loadModels();

        function calculateAngle(a, b, c) {
            if (!a || !b || !c) {
                return 0;
            }
            const aPos = { x: a.x, y: a.y };
            const bPos = { x: b.x, y: b.y };
            const cPos = { x: c.x, y: c.y };
            const radians = Math.atan2(cPos.y - bPos.y, cPos.x - bPos.x) - Math.atan2(aPos.y - bPos.y, aPos.x - bPos.x);
            let angle = Math.abs(radians * 180.0 / Math.PI);
            if (angle > 180.0) {
                angle = 360 - angle;
            }
            return angle;
        }

        async function detectAndAnalyze(currentVideo) {
            if (poseModel && faceModel) {
                try {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const poses = await poseModel.estimatePoses(currentVideo, { flipHorizontal: true });
                    const faces = await faceModel.estimateFaces(currentVideo);

                    if (poses && poses.length > 0) {
                        const pose = poses[0];
                        drawKeypoints(pose.keypoints);
                        detectMovement(pose.keypoints);
                        detectSuspiciousBehavior(pose.keypoints);
                    }
                    if (faces && faces.length > 0) {
                        detectAndRecognizeFaces(faces);
                        drawFaces(faces);
                    }
                } catch (error) {
                    console.error("Error detecting and analyzing:", error);
                }
            }
            requestAnimationFrame(() => detectAndAnalyze(currentVideo));
        }

        function drawKeypoints(keypoints) {
            ctx.fillStyle = "white";
            for (const keypoint of keypoints) {
                if (keypoint.score > 0.5) {
                    ctx.beginPath();
                    ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        }

        function detectMovement(keypoints) {
            if (prevKeypoints) {
                let totalMovement = 0;
                for (let i = 0; i < keypoints.length; i++) {
                    const prevKeypoint = prevKeypoints[i];
                    const keypoint = keypoints[i];
                    if (prevKeypoint && keypoint && prevKeypoint.score > 0.5 && keypoint.score > 0.5) {
                        totalMovement += Math.sqrt(Math.pow(keypoint.x - prevKeypoint.x, 2) + Math.pow(keypoint.y - prevKeypoint.y, 2));
                    }
                }
                if (totalMovement * canvas.width > movementThreshold) {
                    setMessage("Movement Detected!", "red");
                    console.log(`Total movement: ${(totalMovement * canvas.width).toFixed(2)}`);
                    captureCanvas("movement");
                }
            }
            prevKeypoints = keypoints;
        }

        function detectSuspiciousBehavior(keypoints) {
            const leftElbow = keypoints[7];
            const leftShoulder = keypoints[5];
            const leftWrist = keypoints[9];
            const rightElbow = keypoints[8];
            const rightShoulder = keypoints[6];
            const rightWrist = keypoints[10];

            if (leftElbow && leftShoulder && leftWrist &&
                rightElbow && rightShoulder && rightWrist &&
                leftElbow.score > 0.5 && leftShoulder.score > 0.5 && leftWrist.score > 0.5 &&
                rightElbow.score > 0.5 && rightShoulder.score > 0.5 && rightWrist.score > 0.5) {
                let newLeftArmAngle = calculateAngle(leftShoulder, leftElbow, leftWrist);
                let newRightArmAngle = calculateAngle(rightShoulder, rightElbow, rightWrist);

                if (prevAngles["leftArm"] !== undefined && Math.abs(newLeftArmAngle - prevAngles["leftArm"]) > angleChangeThreshold) {
                    setMessage("Suspicious arm movement detected", "orange");
                    console.log("Suspicious arm movement detected (left)");
                    captureCanvas("suspicious_arm_left");
                }
                if (prevAngles["rightArm"] !== undefined && Math.abs(newRightArmAngle - prevAngles["rightArm"]) > angleChangeThreshold) {
                    setMessage("Suspicious arm movement detected", "orange");
                    console.log("Suspicious arm movement detected (right)");
                    captureCanvas("suspicious_arm_right");
                }
                prevAngles["leftArm"] = newLeftArmAngle;
                prevAngles["rightArm"] = newRightArmAngle;
            }
        }

        function drawFaces(faces) {
            ctx.strokeStyle = "red";
            faces.forEach(face => {
                const box = face.box;
                ctx.strokeRect(box.x, box.y, box.width, box.height);
            });
        }

        function detectAndRecognizeFaces(faces) {
            faces.forEach(face => {
                const box = face.box;
                const faceId = `${box.x}_${box.y}_${box.width}_${box.height}`;
                const faceFound = recognizedFaces.find(x => x.faceId === faceId);
                if (!faceFound) {
                    const detectionTime = new Date().toLocaleString();
                    recognizedFaces.push({ faceId: faceId, time: detectionTime });
                    setMessage(`New face detected at ${detectionTime}`, "blue");
                    console.log(`New face detected at ${detectionTime}`);
                    captureCanvas("face");
                }
            });
        }

        async function startWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    video.play();
                    detectAndAnalyze(video);
                };
            } catch (error) {
                console.error("Error accessing webcam:", error);
                setMessage("Error accessing webcam.", "red");
            }
        }

        function handleFile(event) {
            const file = event.target.files[0];
            if (file) {
                video.src = URL.createObjectURL(file);
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    video.play();
                    detectAndAnalyze(video);
                };
            }
        }

        function startRecording() {
            if (!isRecording) {
                recordedChunks = [];
                const stream = canvas.captureStream();
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
                mediaRecorder.ondataavailable = handleDataAvailable;
                mediaRecorder.onstop = downloadVideo; // Download when recording stops
                mediaRecorder.start();
                captureButton.textContent = "Stop Recording";
                recordingIndicator.style.display = 'block';
                isRecording = true;
            } else {
                mediaRecorder.stop();
                captureButton.textContent = "Start Recording";
                recordingIndicator.style.display = 'none';
                isRecording = false;
            }
        }

        function handleDataAvailable(event) {
            if (event.data && event.data.size > 0) {
                recordedChunks.push(event.data);
            }
        }

        function downloadVideo() {
            if (recordedChunks.length === 0) return;
            const blob = new Blob(recordedChunks, { type: "video/webm" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'captured.webm';
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            recordedChunks = []; // Clear chunks after download
        }

        function captureCanvas(type) {
            const image = canvas.toDataURL("image/png");
            const a = document.createElement('a');
            a.href = image;
            a.download = `captured_${type}_${captureCount}.png`;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            captureCount++;
        }

        function setMessage(text, color) {
            messageDiv.textContent = text;
            messageDiv.style.color = color;
        }

        webcamButton.addEventListener('click', startWebcam);
        fileInput.addEventListener('change', handleFile);
        captureButton.addEventListener('click', startRecording);

        // Start webcam on initial load
        startWebcam();
    </script>
</body>
</html>
